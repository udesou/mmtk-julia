/* automatically generated by rust-bindgen 0.60.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const _SETJMP_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __STDC_NO_THREADS__: u32 = 1;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 27;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const _BITS_SETJMP_H: u32 = 1;
pub const HT_N_INLINE: u32 = 32;
pub const AL_N_INLINE: u32 = 29;
pub const MAX_ALIGN: u32 = 4;
pub type __jmp_buf = [::std::os::raw::c_long; 8usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    fn test_field___val() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sigset_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__sigset_t),
                "::",
                stringify!(__val)
            )
        );
    }
    test_field___val();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __jmp_buf_tag {
    pub __jmpbuf: __jmp_buf,
    pub __mask_was_saved: ::std::os::raw::c_int,
    pub __saved_mask: __sigset_t,
}
#[test]
fn bindgen_test_layout___jmp_buf_tag() {
    assert_eq!(
        ::std::mem::size_of::<__jmp_buf_tag>(),
        200usize,
        concat!("Size of: ", stringify!(__jmp_buf_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__jmp_buf_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__jmp_buf_tag))
    );
    fn test_field___jmpbuf() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__jmp_buf_tag>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__jmpbuf) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__jmp_buf_tag),
                "::",
                stringify!(__jmpbuf)
            )
        );
    }
    test_field___jmpbuf();
    fn test_field___mask_was_saved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__jmp_buf_tag>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__mask_was_saved) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(__jmp_buf_tag),
                "::",
                stringify!(__mask_was_saved)
            )
        );
    }
    test_field___mask_was_saved();
    fn test_field___saved_mask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__jmp_buf_tag>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__saved_mask) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(__jmp_buf_tag),
                "::",
                stringify!(__saved_mask)
            )
        );
    }
    test_field___saved_mask();
}
pub type jmp_buf = [__jmp_buf_tag; 1usize];
extern "C" {
    pub fn setjmp(__env: *mut __jmp_buf_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __sigsetjmp(
        __env: *mut __jmp_buf_tag,
        __savemask: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _setjmp(__env: *mut __jmp_buf_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn longjmp(__env: *mut __jmp_buf_tag, __val: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _longjmp(__env: *mut __jmp_buf_tag, __val: ::std::os::raw::c_int);
}
pub type sigjmp_buf = [__jmp_buf_tag; 1usize];
extern "C" {
    pub fn siglongjmp(__env: *mut __jmp_buf_tag, __val: ::std::os::raw::c_int);
}
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type size_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct mmtk__jl_taggedvalue_bits {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
#[test]
fn bindgen_test_layout_mmtk__jl_taggedvalue_bits() {
    assert_eq!(
        ::std::mem::size_of::<mmtk__jl_taggedvalue_bits>(),
        8usize,
        concat!("Size of: ", stringify!(mmtk__jl_taggedvalue_bits))
    );
    assert_eq!(
        ::std::mem::align_of::<mmtk__jl_taggedvalue_bits>(),
        8usize,
        concat!("Alignment of ", stringify!(mmtk__jl_taggedvalue_bits))
    );
}
impl mmtk__jl_taggedvalue_bits {
    #[inline]
    pub fn gc(&self) -> usize {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u64) }
    }
    #[inline]
    pub fn set_gc(&mut self, val: usize) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(gc: usize) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let gc: u64 = unsafe { ::std::mem::transmute(gc) };
            gc as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mmtk__jl_value_t {
    _unused: [u8; 0],
}
pub type mmtk_jl_value_t = mmtk__jl_value_t;
pub type mmtk_jl_taggedvalue_t = mmtk__jl_taggedvalue_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mmtk__jl_taggedvalue_t {
    pub __bindgen_anon_1: mmtk__jl_taggedvalue_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mmtk__jl_taggedvalue_t__bindgen_ty_1 {
    pub header: usize,
    pub next: *mut mmtk_jl_taggedvalue_t,
    pub type_: *mut mmtk_jl_value_t,
    pub bits: mmtk__jl_taggedvalue_bits,
}
#[test]
fn bindgen_test_layout_mmtk__jl_taggedvalue_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<mmtk__jl_taggedvalue_t__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(mmtk__jl_taggedvalue_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<mmtk__jl_taggedvalue_t__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(mmtk__jl_taggedvalue_t__bindgen_ty_1)
        )
    );
    fn test_field_header() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<mmtk__jl_taggedvalue_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).header) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk__jl_taggedvalue_t__bindgen_ty_1),
                "::",
                stringify!(header)
            )
        );
    }
    test_field_header();
    fn test_field_next() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<mmtk__jl_taggedvalue_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk__jl_taggedvalue_t__bindgen_ty_1),
                "::",
                stringify!(next)
            )
        );
    }
    test_field_next();
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<mmtk__jl_taggedvalue_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk__jl_taggedvalue_t__bindgen_ty_1),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_bits() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<mmtk__jl_taggedvalue_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bits) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk__jl_taggedvalue_t__bindgen_ty_1),
                "::",
                stringify!(bits)
            )
        );
    }
    test_field_bits();
}
#[test]
fn bindgen_test_layout_mmtk__jl_taggedvalue_t() {
    assert_eq!(
        ::std::mem::size_of::<mmtk__jl_taggedvalue_t>(),
        8usize,
        concat!("Size of: ", stringify!(mmtk__jl_taggedvalue_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mmtk__jl_taggedvalue_t>(),
        8usize,
        concat!("Alignment of ", stringify!(mmtk__jl_taggedvalue_t))
    );
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct mmtk_jl_array_flags_t {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_mmtk_jl_array_flags_t() {
    assert_eq!(
        ::std::mem::size_of::<mmtk_jl_array_flags_t>(),
        2usize,
        concat!("Size of: ", stringify!(mmtk_jl_array_flags_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mmtk_jl_array_flags_t>(),
        2usize,
        concat!("Alignment of ", stringify!(mmtk_jl_array_flags_t))
    );
}
impl mmtk_jl_array_flags_t {
    #[inline]
    pub fn how(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_how(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn ndims(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 9u8) as u16) }
    }
    #[inline]
    pub fn set_ndims(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn pooled(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_pooled(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ptrarray(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ptrarray(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasptr(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_hasptr(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isshared(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_isshared(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isaligned(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_isaligned(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        how: ::std::os::raw::c_ushort,
        ndims: ::std::os::raw::c_ushort,
        pooled: ::std::os::raw::c_ushort,
        ptrarray: ::std::os::raw::c_ushort,
        hasptr: ::std::os::raw::c_ushort,
        isshared: ::std::os::raw::c_ushort,
        isaligned: ::std::os::raw::c_ushort,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let how: u16 = unsafe { ::std::mem::transmute(how) };
            how as u64
        });
        __bindgen_bitfield_unit.set(2usize, 9u8, {
            let ndims: u16 = unsafe { ::std::mem::transmute(ndims) };
            ndims as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let pooled: u16 = unsafe { ::std::mem::transmute(pooled) };
            pooled as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let ptrarray: u16 = unsafe { ::std::mem::transmute(ptrarray) };
            ptrarray as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let hasptr: u16 = unsafe { ::std::mem::transmute(hasptr) };
            hasptr as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let isshared: u16 = unsafe { ::std::mem::transmute(isshared) };
            isshared as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let isaligned: u16 = unsafe { ::std::mem::transmute(isaligned) };
            isaligned as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mmtk_jl_datatype_layout_t {
    pub nfields: u32,
    pub npointers: u32,
    pub first_ptr: i32,
    pub alignment: u16,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: u8,
}
#[test]
fn bindgen_test_layout_mmtk_jl_datatype_layout_t() {
    assert_eq!(
        ::std::mem::size_of::<mmtk_jl_datatype_layout_t>(),
        16usize,
        concat!("Size of: ", stringify!(mmtk_jl_datatype_layout_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mmtk_jl_datatype_layout_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mmtk_jl_datatype_layout_t))
    );
    fn test_field_nfields() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk_jl_datatype_layout_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nfields) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk_jl_datatype_layout_t),
                "::",
                stringify!(nfields)
            )
        );
    }
    test_field_nfields();
    fn test_field_npointers() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk_jl_datatype_layout_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).npointers) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk_jl_datatype_layout_t),
                "::",
                stringify!(npointers)
            )
        );
    }
    test_field_npointers();
    fn test_field_first_ptr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk_jl_datatype_layout_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).first_ptr) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk_jl_datatype_layout_t),
                "::",
                stringify!(first_ptr)
            )
        );
    }
    test_field_first_ptr();
    fn test_field_alignment() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk_jl_datatype_layout_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).alignment) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk_jl_datatype_layout_t),
                "::",
                stringify!(alignment)
            )
        );
    }
    test_field_alignment();
}
impl mmtk_jl_datatype_layout_t {
    #[inline]
    pub fn haspadding(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_haspadding(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fielddesc_type(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_fielddesc_type(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        haspadding: u16,
        fielddesc_type: u16,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let haspadding: u16 = unsafe { ::std::mem::transmute(haspadding) };
            haspadding as u64
        });
        __bindgen_bitfield_unit.set(1usize, 2u8, {
            let fielddesc_type: u16 = unsafe { ::std::mem::transmute(fielddesc_type) };
            fielddesc_type as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mmtk_jl_typename_t {
    pub name: *mut ::std::os::raw::c_void,
    pub module: *mut mmtk__jl_module_t,
    pub names: *mut ::std::os::raw::c_void,
    pub atomicfields: *const u32,
    pub constfields: *const u32,
    pub wrapper: *mut ::std::os::raw::c_void,
    pub cache: *mut ::std::os::raw::c_void,
    pub linearcache: *mut ::std::os::raw::c_void,
    pub mt: *mut ::std::os::raw::c_void,
    pub partial: *mut ::std::os::raw::c_void,
    pub hash: isize,
    pub n_uninitialized: i32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub max_methods: u8,
}
#[test]
fn bindgen_test_layout_mmtk_jl_typename_t() {
    assert_eq!(
        ::std::mem::size_of::<mmtk_jl_typename_t>(),
        96usize,
        concat!("Size of: ", stringify!(mmtk_jl_typename_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mmtk_jl_typename_t>(),
        8usize,
        concat!("Alignment of ", stringify!(mmtk_jl_typename_t))
    );
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk_jl_typename_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk_jl_typename_t),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_module() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk_jl_typename_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).module) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk_jl_typename_t),
                "::",
                stringify!(module)
            )
        );
    }
    test_field_module();
    fn test_field_names() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk_jl_typename_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).names) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk_jl_typename_t),
                "::",
                stringify!(names)
            )
        );
    }
    test_field_names();
    fn test_field_atomicfields() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk_jl_typename_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).atomicfields) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk_jl_typename_t),
                "::",
                stringify!(atomicfields)
            )
        );
    }
    test_field_atomicfields();
    fn test_field_constfields() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk_jl_typename_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).constfields) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk_jl_typename_t),
                "::",
                stringify!(constfields)
            )
        );
    }
    test_field_constfields();
    fn test_field_wrapper() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk_jl_typename_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).wrapper) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk_jl_typename_t),
                "::",
                stringify!(wrapper)
            )
        );
    }
    test_field_wrapper();
    fn test_field_cache() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk_jl_typename_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cache) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk_jl_typename_t),
                "::",
                stringify!(cache)
            )
        );
    }
    test_field_cache();
    fn test_field_linearcache() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk_jl_typename_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).linearcache) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk_jl_typename_t),
                "::",
                stringify!(linearcache)
            )
        );
    }
    test_field_linearcache();
    fn test_field_mt() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk_jl_typename_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mt) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk_jl_typename_t),
                "::",
                stringify!(mt)
            )
        );
    }
    test_field_mt();
    fn test_field_partial() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk_jl_typename_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).partial) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk_jl_typename_t),
                "::",
                stringify!(partial)
            )
        );
    }
    test_field_partial();
    fn test_field_hash() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk_jl_typename_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hash) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk_jl_typename_t),
                "::",
                stringify!(hash)
            )
        );
    }
    test_field_hash();
    fn test_field_n_uninitialized() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk_jl_typename_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).n_uninitialized) as usize - ptr as usize
            },
            84usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk_jl_typename_t),
                "::",
                stringify!(n_uninitialized)
            )
        );
    }
    test_field_n_uninitialized();
    fn test_field_max_methods() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk_jl_typename_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).max_methods) as usize - ptr as usize
            },
            89usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk_jl_typename_t),
                "::",
                stringify!(max_methods)
            )
        );
    }
    test_field_max_methods();
}
impl mmtk_jl_typename_t {
    #[inline]
    pub fn abstract_(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_abstract(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mutabl(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mutabl(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mayinlinealloc(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mayinlinealloc(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        abstract_: u8,
        mutabl: u8,
        mayinlinealloc: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let abstract_: u8 = unsafe { ::std::mem::transmute(abstract_) };
            abstract_ as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mutabl: u8 = unsafe { ::std::mem::transmute(mutabl) };
            mutabl as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mayinlinealloc: u8 = unsafe { ::std::mem::transmute(mayinlinealloc) };
            mayinlinealloc as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mmtk_jl_svec_t {
    pub length: size_t,
}
#[test]
fn bindgen_test_layout_mmtk_jl_svec_t() {
    assert_eq!(
        ::std::mem::size_of::<mmtk_jl_svec_t>(),
        8usize,
        concat!("Size of: ", stringify!(mmtk_jl_svec_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mmtk_jl_svec_t>(),
        8usize,
        concat!("Alignment of ", stringify!(mmtk_jl_svec_t))
    );
    fn test_field_length() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk_jl_svec_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk_jl_svec_t),
                "::",
                stringify!(length)
            )
        );
    }
    test_field_length();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mmtk__jl_datatype_t {
    pub name: *mut mmtk_jl_typename_t,
    pub super_: *mut mmtk__jl_datatype_t,
    pub parameters: *mut mmtk_jl_svec_t,
    pub types: *mut mmtk_jl_svec_t,
    pub instance: *mut mmtk_jl_value_t,
    pub layout: *const mmtk_jl_datatype_layout_t,
    pub size: i32,
    pub hash: u32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
#[test]
fn bindgen_test_layout_mmtk__jl_datatype_t() {
    assert_eq!(
        ::std::mem::size_of::<mmtk__jl_datatype_t>(),
        64usize,
        concat!("Size of: ", stringify!(mmtk__jl_datatype_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mmtk__jl_datatype_t>(),
        8usize,
        concat!("Alignment of ", stringify!(mmtk__jl_datatype_t))
    );
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk__jl_datatype_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk__jl_datatype_t),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_super() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk__jl_datatype_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).super_) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk__jl_datatype_t),
                "::",
                stringify!(super_)
            )
        );
    }
    test_field_super();
    fn test_field_parameters() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk__jl_datatype_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).parameters) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk__jl_datatype_t),
                "::",
                stringify!(parameters)
            )
        );
    }
    test_field_parameters();
    fn test_field_types() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk__jl_datatype_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).types) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk__jl_datatype_t),
                "::",
                stringify!(types)
            )
        );
    }
    test_field_types();
    fn test_field_instance() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk__jl_datatype_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).instance) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk__jl_datatype_t),
                "::",
                stringify!(instance)
            )
        );
    }
    test_field_instance();
    fn test_field_layout() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk__jl_datatype_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).layout) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk__jl_datatype_t),
                "::",
                stringify!(layout)
            )
        );
    }
    test_field_layout();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk__jl_datatype_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk__jl_datatype_t),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_hash() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk__jl_datatype_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hash) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk__jl_datatype_t),
                "::",
                stringify!(hash)
            )
        );
    }
    test_field_hash();
}
impl mmtk__jl_datatype_t {
    #[inline]
    pub fn hasfreetypevars(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hasfreetypevars(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isconcretetype(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_isconcretetype(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isdispatchtuple(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_isdispatchtuple(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isbitstype(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_isbitstype(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn zeroinit(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_zeroinit(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_concrete_subtype(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_has_concrete_subtype(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cached_by_hash(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_cached_by_hash(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        hasfreetypevars: u8,
        isconcretetype: u8,
        isdispatchtuple: u8,
        isbitstype: u8,
        zeroinit: u8,
        has_concrete_subtype: u8,
        cached_by_hash: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let hasfreetypevars: u8 = unsafe { ::std::mem::transmute(hasfreetypevars) };
            hasfreetypevars as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let isconcretetype: u8 = unsafe { ::std::mem::transmute(isconcretetype) };
            isconcretetype as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let isdispatchtuple: u8 = unsafe { ::std::mem::transmute(isdispatchtuple) };
            isdispatchtuple as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let isbitstype: u8 = unsafe { ::std::mem::transmute(isbitstype) };
            isbitstype as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let zeroinit: u8 = unsafe { ::std::mem::transmute(zeroinit) };
            zeroinit as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let has_concrete_subtype: u8 = unsafe { ::std::mem::transmute(has_concrete_subtype) };
            has_concrete_subtype as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let cached_by_hash: u8 = unsafe { ::std::mem::transmute(cached_by_hash) };
            cached_by_hash as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type mmtk_jl_datatype_t = mmtk__jl_datatype_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mmtk_jl_array_t {
    pub data: *mut ::std::os::raw::c_void,
    pub length: size_t,
    pub flags: mmtk_jl_array_flags_t,
    pub elsize: u16,
    pub offset: u32,
    pub nrows: size_t,
    pub __bindgen_anon_1: mmtk_jl_array_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mmtk_jl_array_t__bindgen_ty_1 {
    pub maxsize: size_t,
    pub ncols: size_t,
}
#[test]
fn bindgen_test_layout_mmtk_jl_array_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<mmtk_jl_array_t__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(mmtk_jl_array_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<mmtk_jl_array_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(mmtk_jl_array_t__bindgen_ty_1))
    );
    fn test_field_maxsize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk_jl_array_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxsize) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk_jl_array_t__bindgen_ty_1),
                "::",
                stringify!(maxsize)
            )
        );
    }
    test_field_maxsize();
    fn test_field_ncols() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk_jl_array_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ncols) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk_jl_array_t__bindgen_ty_1),
                "::",
                stringify!(ncols)
            )
        );
    }
    test_field_ncols();
}
#[test]
fn bindgen_test_layout_mmtk_jl_array_t() {
    assert_eq!(
        ::std::mem::size_of::<mmtk_jl_array_t>(),
        40usize,
        concat!("Size of: ", stringify!(mmtk_jl_array_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mmtk_jl_array_t>(),
        8usize,
        concat!("Alignment of ", stringify!(mmtk_jl_array_t))
    );
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk_jl_array_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk_jl_array_t),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
    fn test_field_length() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk_jl_array_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk_jl_array_t),
                "::",
                stringify!(length)
            )
        );
    }
    test_field_length();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk_jl_array_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk_jl_array_t),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_elsize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk_jl_array_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).elsize) as usize - ptr as usize
            },
            18usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk_jl_array_t),
                "::",
                stringify!(elsize)
            )
        );
    }
    test_field_elsize();
    fn test_field_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk_jl_array_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk_jl_array_t),
                "::",
                stringify!(offset)
            )
        );
    }
    test_field_offset();
    fn test_field_nrows() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk_jl_array_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nrows) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk_jl_array_t),
                "::",
                stringify!(nrows)
            )
        );
    }
    test_field_nrows();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mmtk__jl_sym_t {
    pub left: u64,
    pub right: u64,
    pub hash: usize,
}
#[test]
fn bindgen_test_layout_mmtk__jl_sym_t() {
    assert_eq!(
        ::std::mem::size_of::<mmtk__jl_sym_t>(),
        24usize,
        concat!("Size of: ", stringify!(mmtk__jl_sym_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mmtk__jl_sym_t>(),
        8usize,
        concat!("Alignment of ", stringify!(mmtk__jl_sym_t))
    );
    fn test_field_left() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk__jl_sym_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).left) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk__jl_sym_t),
                "::",
                stringify!(left)
            )
        );
    }
    test_field_left();
    fn test_field_right() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk__jl_sym_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).right) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk__jl_sym_t),
                "::",
                stringify!(right)
            )
        );
    }
    test_field_right();
    fn test_field_hash() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk__jl_sym_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hash) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk__jl_sym_t),
                "::",
                stringify!(hash)
            )
        );
    }
    test_field_hash();
}
pub type mmtk_jl_sym_t = mmtk__jl_sym_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mmtk_jl_binding_t {
    pub name: *mut mmtk_jl_sym_t,
    pub value: u64,
    pub globalref: u64,
    pub owner: *mut mmtk__jl_module_t,
    pub ty: u64,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
#[test]
fn bindgen_test_layout_mmtk_jl_binding_t() {
    assert_eq!(
        ::std::mem::size_of::<mmtk_jl_binding_t>(),
        48usize,
        concat!("Size of: ", stringify!(mmtk_jl_binding_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mmtk_jl_binding_t>(),
        8usize,
        concat!("Alignment of ", stringify!(mmtk_jl_binding_t))
    );
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk_jl_binding_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk_jl_binding_t),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk_jl_binding_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk_jl_binding_t),
                "::",
                stringify!(value)
            )
        );
    }
    test_field_value();
    fn test_field_globalref() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk_jl_binding_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).globalref) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk_jl_binding_t),
                "::",
                stringify!(globalref)
            )
        );
    }
    test_field_globalref();
    fn test_field_owner() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk_jl_binding_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).owner) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk_jl_binding_t),
                "::",
                stringify!(owner)
            )
        );
    }
    test_field_owner();
    fn test_field_ty() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk_jl_binding_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ty) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk_jl_binding_t),
                "::",
                stringify!(ty)
            )
        );
    }
    test_field_ty();
}
impl mmtk_jl_binding_t {
    #[inline]
    pub fn constp(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_constp(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn exportp(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_exportp(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn imported(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_imported(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn deprecated(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_deprecated(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        constp: u8,
        exportp: u8,
        imported: u8,
        deprecated: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let constp: u8 = unsafe { ::std::mem::transmute(constp) };
            constp as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let exportp: u8 = unsafe { ::std::mem::transmute(exportp) };
            exportp as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let imported: u8 = unsafe { ::std::mem::transmute(imported) };
            imported as u64
        });
        __bindgen_bitfield_unit.set(3usize, 2u8, {
            let deprecated: u8 = unsafe { ::std::mem::transmute(deprecated) };
            deprecated as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mmtk_htable_t {
    pub size: size_t,
    pub table: *mut *mut ::std::os::raw::c_void,
    pub _space: [*mut ::std::os::raw::c_void; 32usize],
}
#[test]
fn bindgen_test_layout_mmtk_htable_t() {
    assert_eq!(
        ::std::mem::size_of::<mmtk_htable_t>(),
        272usize,
        concat!("Size of: ", stringify!(mmtk_htable_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mmtk_htable_t>(),
        8usize,
        concat!("Alignment of ", stringify!(mmtk_htable_t))
    );
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk_htable_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk_htable_t),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_table() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk_htable_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).table) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk_htable_t),
                "::",
                stringify!(table)
            )
        );
    }
    test_field_table();
    fn test_field__space() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk_htable_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._space) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk_htable_t),
                "::",
                stringify!(_space)
            )
        );
    }
    test_field__space();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mmtk_arraylist_t {
    pub len: size_t,
    pub max: size_t,
    pub items: *mut *mut ::std::os::raw::c_void,
    pub _space: [*mut ::std::os::raw::c_void; 29usize],
}
#[test]
fn bindgen_test_layout_mmtk_arraylist_t() {
    assert_eq!(
        ::std::mem::size_of::<mmtk_arraylist_t>(),
        256usize,
        concat!("Size of: ", stringify!(mmtk_arraylist_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mmtk_arraylist_t>(),
        8usize,
        concat!("Alignment of ", stringify!(mmtk_arraylist_t))
    );
    fn test_field_len() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk_arraylist_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk_arraylist_t),
                "::",
                stringify!(len)
            )
        );
    }
    test_field_len();
    fn test_field_max() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk_arraylist_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).max) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk_arraylist_t),
                "::",
                stringify!(max)
            )
        );
    }
    test_field_max();
    fn test_field_items() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk_arraylist_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).items) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk_arraylist_t),
                "::",
                stringify!(items)
            )
        );
    }
    test_field_items();
    fn test_field__space() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk_arraylist_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._space) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk_arraylist_t),
                "::",
                stringify!(_space)
            )
        );
    }
    test_field__space();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mmtk_jl_uuid_t {
    pub hi: u64,
    pub lo: u64,
}
#[test]
fn bindgen_test_layout_mmtk_jl_uuid_t() {
    assert_eq!(
        ::std::mem::size_of::<mmtk_jl_uuid_t>(),
        16usize,
        concat!("Size of: ", stringify!(mmtk_jl_uuid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mmtk_jl_uuid_t>(),
        8usize,
        concat!("Alignment of ", stringify!(mmtk_jl_uuid_t))
    );
    fn test_field_hi() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk_jl_uuid_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hi) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk_jl_uuid_t),
                "::",
                stringify!(hi)
            )
        );
    }
    test_field_hi();
    fn test_field_lo() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk_jl_uuid_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).lo) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk_jl_uuid_t),
                "::",
                stringify!(lo)
            )
        );
    }
    test_field_lo();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mmtk_jl_mutex_t {
    pub owner: u64,
    pub count: u32,
}
#[test]
fn bindgen_test_layout_mmtk_jl_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<mmtk_jl_mutex_t>(),
        16usize,
        concat!("Size of: ", stringify!(mmtk_jl_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mmtk_jl_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(mmtk_jl_mutex_t))
    );
    fn test_field_owner() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk_jl_mutex_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).owner) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk_jl_mutex_t),
                "::",
                stringify!(owner)
            )
        );
    }
    test_field_owner();
    fn test_field_count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk_jl_mutex_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk_jl_mutex_t),
                "::",
                stringify!(count)
            )
        );
    }
    test_field_count();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mmtk__jl_module_t {
    pub name: *mut ::std::os::raw::c_void,
    pub parent: *mut mmtk__jl_module_t,
    pub bindings: mmtk_htable_t,
    pub usings: mmtk_arraylist_t,
    pub build_id: u64,
    pub uuid: mmtk_jl_uuid_t,
    pub primary_world: size_t,
    pub counter: u32,
    pub nospecialize: i32,
    pub optlevel: i8,
    pub compile: i8,
    pub infer: i8,
    pub istopmod: u8,
    pub max_methods: i8,
    pub lock: mmtk_jl_mutex_t,
}
#[test]
fn bindgen_test_layout_mmtk__jl_module_t() {
    assert_eq!(
        ::std::mem::size_of::<mmtk__jl_module_t>(),
        608usize,
        concat!("Size of: ", stringify!(mmtk__jl_module_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mmtk__jl_module_t>(),
        8usize,
        concat!("Alignment of ", stringify!(mmtk__jl_module_t))
    );
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk__jl_module_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk__jl_module_t),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_parent() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk__jl_module_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk__jl_module_t),
                "::",
                stringify!(parent)
            )
        );
    }
    test_field_parent();
    fn test_field_bindings() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk__jl_module_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bindings) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk__jl_module_t),
                "::",
                stringify!(bindings)
            )
        );
    }
    test_field_bindings();
    fn test_field_usings() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk__jl_module_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).usings) as usize - ptr as usize
            },
            288usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk__jl_module_t),
                "::",
                stringify!(usings)
            )
        );
    }
    test_field_usings();
    fn test_field_build_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk__jl_module_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).build_id) as usize - ptr as usize
            },
            544usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk__jl_module_t),
                "::",
                stringify!(build_id)
            )
        );
    }
    test_field_build_id();
    fn test_field_uuid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk__jl_module_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uuid) as usize - ptr as usize
            },
            552usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk__jl_module_t),
                "::",
                stringify!(uuid)
            )
        );
    }
    test_field_uuid();
    fn test_field_primary_world() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk__jl_module_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).primary_world) as usize - ptr as usize
            },
            568usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk__jl_module_t),
                "::",
                stringify!(primary_world)
            )
        );
    }
    test_field_primary_world();
    fn test_field_counter() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk__jl_module_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).counter) as usize - ptr as usize
            },
            576usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk__jl_module_t),
                "::",
                stringify!(counter)
            )
        );
    }
    test_field_counter();
    fn test_field_nospecialize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk__jl_module_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nospecialize) as usize - ptr as usize
            },
            580usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk__jl_module_t),
                "::",
                stringify!(nospecialize)
            )
        );
    }
    test_field_nospecialize();
    fn test_field_optlevel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk__jl_module_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).optlevel) as usize - ptr as usize
            },
            584usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk__jl_module_t),
                "::",
                stringify!(optlevel)
            )
        );
    }
    test_field_optlevel();
    fn test_field_compile() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk__jl_module_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).compile) as usize - ptr as usize
            },
            585usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk__jl_module_t),
                "::",
                stringify!(compile)
            )
        );
    }
    test_field_compile();
    fn test_field_infer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk__jl_module_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).infer) as usize - ptr as usize
            },
            586usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk__jl_module_t),
                "::",
                stringify!(infer)
            )
        );
    }
    test_field_infer();
    fn test_field_istopmod() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk__jl_module_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).istopmod) as usize - ptr as usize
            },
            587usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk__jl_module_t),
                "::",
                stringify!(istopmod)
            )
        );
    }
    test_field_istopmod();
    fn test_field_max_methods() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk__jl_module_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).max_methods) as usize - ptr as usize
            },
            588usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk__jl_module_t),
                "::",
                stringify!(max_methods)
            )
        );
    }
    test_field_max_methods();
    fn test_field_lock() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk__jl_module_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).lock) as usize - ptr as usize
            },
            592usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk__jl_module_t),
                "::",
                stringify!(lock)
            )
        );
    }
    test_field_lock();
}
pub type mmtk_jl_module_t = mmtk__jl_module_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mmtk__jl_excstack_t {
    pub top: size_t,
    pub reserved_size: size_t,
}
#[test]
fn bindgen_test_layout_mmtk__jl_excstack_t() {
    assert_eq!(
        ::std::mem::size_of::<mmtk__jl_excstack_t>(),
        16usize,
        concat!("Size of: ", stringify!(mmtk__jl_excstack_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mmtk__jl_excstack_t>(),
        8usize,
        concat!("Alignment of ", stringify!(mmtk__jl_excstack_t))
    );
    fn test_field_top() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk__jl_excstack_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).top) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk__jl_excstack_t),
                "::",
                stringify!(top)
            )
        );
    }
    test_field_top();
    fn test_field_reserved_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk__jl_excstack_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved_size) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk__jl_excstack_t),
                "::",
                stringify!(reserved_size)
            )
        );
    }
    test_field_reserved_size();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mmtk__jl_bt_element_t {
    pub __bindgen_anon_1: mmtk__jl_bt_element_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mmtk__jl_bt_element_t__bindgen_ty_1 {
    pub uintptr: usize,
    pub jlvalue: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_mmtk__jl_bt_element_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<mmtk__jl_bt_element_t__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(mmtk__jl_bt_element_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<mmtk__jl_bt_element_t__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(mmtk__jl_bt_element_t__bindgen_ty_1)
        )
    );
    fn test_field_uintptr() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<mmtk__jl_bt_element_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uintptr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk__jl_bt_element_t__bindgen_ty_1),
                "::",
                stringify!(uintptr)
            )
        );
    }
    test_field_uintptr();
    fn test_field_jlvalue() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<mmtk__jl_bt_element_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).jlvalue) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk__jl_bt_element_t__bindgen_ty_1),
                "::",
                stringify!(jlvalue)
            )
        );
    }
    test_field_jlvalue();
}
#[test]
fn bindgen_test_layout_mmtk__jl_bt_element_t() {
    assert_eq!(
        ::std::mem::size_of::<mmtk__jl_bt_element_t>(),
        8usize,
        concat!("Size of: ", stringify!(mmtk__jl_bt_element_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mmtk__jl_bt_element_t>(),
        8usize,
        concat!("Alignment of ", stringify!(mmtk__jl_bt_element_t))
    );
}
pub type mmtk_jl_bt_element_t = mmtk__jl_bt_element_t;
pub type mmtk_jl_excstack_t = mmtk__jl_excstack_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mmtk_jl_stack_context_t {
    pub uc_mcontext: sigjmp_buf,
}
#[test]
fn bindgen_test_layout_mmtk_jl_stack_context_t() {
    assert_eq!(
        ::std::mem::size_of::<mmtk_jl_stack_context_t>(),
        200usize,
        concat!("Size of: ", stringify!(mmtk_jl_stack_context_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mmtk_jl_stack_context_t>(),
        8usize,
        concat!("Alignment of ", stringify!(mmtk_jl_stack_context_t))
    );
    fn test_field_uc_mcontext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk_jl_stack_context_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uc_mcontext) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk_jl_stack_context_t),
                "::",
                stringify!(uc_mcontext)
            )
        );
    }
    test_field_uc_mcontext();
}
pub type mmtk__jl_ucontext_t = mmtk_jl_stack_context_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mmtk_jl_ucontext_t {
    pub __bindgen_anon_1: mmtk_jl_ucontext_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mmtk_jl_ucontext_t__bindgen_ty_1 {
    pub ctx: mmtk__jl_ucontext_t,
    pub copy_ctx: mmtk_jl_stack_context_t,
}
#[test]
fn bindgen_test_layout_mmtk_jl_ucontext_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<mmtk_jl_ucontext_t__bindgen_ty_1>(),
        200usize,
        concat!("Size of: ", stringify!(mmtk_jl_ucontext_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<mmtk_jl_ucontext_t__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(mmtk_jl_ucontext_t__bindgen_ty_1)
        )
    );
    fn test_field_ctx() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk_jl_ucontext_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ctx) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk_jl_ucontext_t__bindgen_ty_1),
                "::",
                stringify!(ctx)
            )
        );
    }
    test_field_ctx();
    fn test_field_copy_ctx() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk_jl_ucontext_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).copy_ctx) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk_jl_ucontext_t__bindgen_ty_1),
                "::",
                stringify!(copy_ctx)
            )
        );
    }
    test_field_copy_ctx();
}
#[test]
fn bindgen_test_layout_mmtk_jl_ucontext_t() {
    assert_eq!(
        ::std::mem::size_of::<mmtk_jl_ucontext_t>(),
        200usize,
        concat!("Size of: ", stringify!(mmtk_jl_ucontext_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mmtk_jl_ucontext_t>(),
        8usize,
        concat!("Alignment of ", stringify!(mmtk_jl_ucontext_t))
    );
}
pub type mmtk_jl_gcframe_t = mmtk__jl_gcframe_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mmtk__jl_gcframe_t {
    pub nroots: size_t,
    pub prev: *mut mmtk__jl_gcframe_t,
}
#[test]
fn bindgen_test_layout_mmtk__jl_gcframe_t() {
    assert_eq!(
        ::std::mem::size_of::<mmtk__jl_gcframe_t>(),
        16usize,
        concat!("Size of: ", stringify!(mmtk__jl_gcframe_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mmtk__jl_gcframe_t>(),
        8usize,
        concat!("Alignment of ", stringify!(mmtk__jl_gcframe_t))
    );
    fn test_field_nroots() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk__jl_gcframe_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nroots) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk__jl_gcframe_t),
                "::",
                stringify!(nroots)
            )
        );
    }
    test_field_nroots();
    fn test_field_prev() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk__jl_gcframe_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).prev) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk__jl_gcframe_t),
                "::",
                stringify!(prev)
            )
        );
    }
    test_field_prev();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mmtk__jl_task_t {
    pub next: *mut ::std::os::raw::c_void,
    pub queue: *mut ::std::os::raw::c_void,
    pub tls: *mut ::std::os::raw::c_void,
    pub donenotify: *mut ::std::os::raw::c_void,
    pub result: *mut ::std::os::raw::c_void,
    pub logstate: *mut ::std::os::raw::c_void,
    pub start: *mut ::std::os::raw::c_void,
    pub rngState: [u64; 4usize],
    pub _state: u8,
    pub sticky: u8,
    pub _isexception: u8,
    pub tid: i16,
    pub threadpoolid: i8,
    pub gcstack: *mut mmtk_jl_gcframe_t,
    pub world_age: size_t,
    pub ptls: *mut ::std::os::raw::c_void,
    pub excstack: *mut mmtk_jl_excstack_t,
    pub eh: *mut ::std::os::raw::c_void,
    pub ctx: mmtk_jl_ucontext_t,
    pub stkbuf: *mut ::std::os::raw::c_void,
    pub bufsz: size_t,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub __bindgen_padding_0: u32,
}
#[test]
fn bindgen_test_layout_mmtk__jl_task_t() {
    assert_eq!(
        ::std::mem::size_of::<mmtk__jl_task_t>(),
        360usize,
        concat!("Size of: ", stringify!(mmtk__jl_task_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mmtk__jl_task_t>(),
        8usize,
        concat!("Alignment of ", stringify!(mmtk__jl_task_t))
    );
    fn test_field_next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk__jl_task_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk__jl_task_t),
                "::",
                stringify!(next)
            )
        );
    }
    test_field_next();
    fn test_field_queue() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk__jl_task_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).queue) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk__jl_task_t),
                "::",
                stringify!(queue)
            )
        );
    }
    test_field_queue();
    fn test_field_tls() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk__jl_task_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tls) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk__jl_task_t),
                "::",
                stringify!(tls)
            )
        );
    }
    test_field_tls();
    fn test_field_donenotify() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk__jl_task_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).donenotify) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk__jl_task_t),
                "::",
                stringify!(donenotify)
            )
        );
    }
    test_field_donenotify();
    fn test_field_result() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk__jl_task_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).result) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk__jl_task_t),
                "::",
                stringify!(result)
            )
        );
    }
    test_field_result();
    fn test_field_logstate() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk__jl_task_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).logstate) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk__jl_task_t),
                "::",
                stringify!(logstate)
            )
        );
    }
    test_field_logstate();
    fn test_field_start() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk__jl_task_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).start) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk__jl_task_t),
                "::",
                stringify!(start)
            )
        );
    }
    test_field_start();
    fn test_field_rngState() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk__jl_task_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rngState) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk__jl_task_t),
                "::",
                stringify!(rngState)
            )
        );
    }
    test_field_rngState();
    fn test_field__state() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk__jl_task_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._state) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk__jl_task_t),
                "::",
                stringify!(_state)
            )
        );
    }
    test_field__state();
    fn test_field_sticky() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk__jl_task_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sticky) as usize - ptr as usize
            },
            89usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk__jl_task_t),
                "::",
                stringify!(sticky)
            )
        );
    }
    test_field_sticky();
    fn test_field__isexception() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk__jl_task_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._isexception) as usize - ptr as usize
            },
            90usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk__jl_task_t),
                "::",
                stringify!(_isexception)
            )
        );
    }
    test_field__isexception();
    fn test_field_tid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk__jl_task_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tid) as usize - ptr as usize
            },
            92usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk__jl_task_t),
                "::",
                stringify!(tid)
            )
        );
    }
    test_field_tid();
    fn test_field_threadpoolid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk__jl_task_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).threadpoolid) as usize - ptr as usize
            },
            94usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk__jl_task_t),
                "::",
                stringify!(threadpoolid)
            )
        );
    }
    test_field_threadpoolid();
    fn test_field_gcstack() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk__jl_task_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gcstack) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk__jl_task_t),
                "::",
                stringify!(gcstack)
            )
        );
    }
    test_field_gcstack();
    fn test_field_world_age() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk__jl_task_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).world_age) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk__jl_task_t),
                "::",
                stringify!(world_age)
            )
        );
    }
    test_field_world_age();
    fn test_field_ptls() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk__jl_task_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ptls) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk__jl_task_t),
                "::",
                stringify!(ptls)
            )
        );
    }
    test_field_ptls();
    fn test_field_excstack() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk__jl_task_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).excstack) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk__jl_task_t),
                "::",
                stringify!(excstack)
            )
        );
    }
    test_field_excstack();
    fn test_field_eh() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk__jl_task_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).eh) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk__jl_task_t),
                "::",
                stringify!(eh)
            )
        );
    }
    test_field_eh();
    fn test_field_ctx() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk__jl_task_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ctx) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk__jl_task_t),
                "::",
                stringify!(ctx)
            )
        );
    }
    test_field_ctx();
    fn test_field_stkbuf() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk__jl_task_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).stkbuf) as usize - ptr as usize
            },
            336usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk__jl_task_t),
                "::",
                stringify!(stkbuf)
            )
        );
    }
    test_field_stkbuf();
    fn test_field_bufsz() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk__jl_task_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bufsz) as usize - ptr as usize
            },
            344usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk__jl_task_t),
                "::",
                stringify!(bufsz)
            )
        );
    }
    test_field_bufsz();
}
impl mmtk__jl_task_t {
    #[inline]
    pub fn copy_stack(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_copy_stack(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn started(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_started(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        copy_stack: ::std::os::raw::c_uint,
        started: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 31u8, {
            let copy_stack: u32 = unsafe { ::std::mem::transmute(copy_stack) };
            copy_stack as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let started: u32 = unsafe { ::std::mem::transmute(started) };
            started as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type mmtk_jl_task_t = mmtk__jl_task_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mmtk_jl_weakref_t {
    pub value: *mut mmtk_jl_value_t,
}
#[test]
fn bindgen_test_layout_mmtk_jl_weakref_t() {
    assert_eq!(
        ::std::mem::size_of::<mmtk_jl_weakref_t>(),
        8usize,
        concat!("Size of: ", stringify!(mmtk_jl_weakref_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mmtk_jl_weakref_t>(),
        8usize,
        concat!("Alignment of ", stringify!(mmtk_jl_weakref_t))
    );
    fn test_field_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mmtk_jl_weakref_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mmtk_jl_weakref_t),
                "::",
                stringify!(value)
            )
        );
    }
    test_field_value();
}
